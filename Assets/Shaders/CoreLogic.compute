//enable debug symbols
#pragma enable_d3d11_debug_symbols

#define PI 3.14159265358979323846

struct Particle
{
    float3 position;
	float3 velocity;
    float density;
	float particleMass;
};

RWStructuredBuffer<float3> particleRenderPositions;
RWStructuredBuffer<Particle> particleRead;
RWStructuredBuffer<Particle> particleWrite;

////To be set from GPU controller

uint nParticles;
float time;
uint frame;
float viscosityCoefficient;
float stiffnessCoefficient;
float restDensity;
float interactionRadius;

float timeStep;

uint pcg(uint v) {
	uint state = v * 747796405u + 2891336453u;
	uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
	return (word >> 22u) ^ word;
}
  
float pcgf(uint v) {
	return float(pcg(v)) / float(0xffffffffu);
}

float SmoothingKernel(float distance, float radius)
{
	distance = distance / radius;
	float weight = exp(-distance * distance);
	return weight;
}

float WPoly(float3 deltaPos, float h){
	float dst = length(deltaPos);
    if (dst > 0 && dst <= h)
	{
		float coefA = 4.0 / (PI*pow(h, 8.0));
		float v = h*h - dst*dst;
		return coefA * pow(v, 3.0);
	}
	return 0;
}

float EquationOfState(float density, float restDensity)
{
	return stiffnessCoefficient * (density - restDensity);
}

//need to add gradient spline kernel
float3 CalculateAcceleration(Particle particle, uint currentParticleIdx)
{
	float3 acceleration = float3(0,0,0);
	for(uint i = 0; i < nParticles; i++)
	{	
		if(i == currentParticleIdx) { continue; } //dont calculate self force
		Particle neighbour = particleRead[i];
		float3 deltaPos = particle.position - neighbour.position;
		float weight = WPoly(deltaPos, interactionRadius); // SmoothingKernel(length(deltaPos), interactionRadius);

		//pressure
		float density = 0.5 * (particle.density + neighbour.density);
		float pressure = EquationOfState(density, restDensity);
		acceleration += pressure * weight * deltaPos;

		//viscosity
		float3 dir = deltaPos / max(length(deltaPos), 0.0001);
		float3 relativeVelocity = particle.velocity - neighbour.velocity;
		acceleration -= viscosityCoefficient * dot(relativeVelocity, dir) * weight * dir;
	}

	//add attraction to zero (like a planet)
	float3 attr_point = float3(0,0,0);
	acceleration += (attr_point - particle.position) * 0.001;

	return acceleration;
}

#pragma kernel ParticleIntegration 
[numthreads(64,1,1)]
void ParticleIntegration(uint3 id : SV_DispatchThreadID)
{
	uint currentParticleIdx = id.x;
	if(currentParticleIdx >= nParticles){return;}

	Particle particle = particleRead[currentParticleIdx];

	if(frame == 0) {
		particle.velocity = float3(0.0,0.0,0.0);
		particle.position = float3(pcgf(currentParticleIdx), pcgf(currentParticleIdx+5), 0.0);
		//remap to -2,2
		particle.position.xy = particle.position.xy * 4.0 - 2.0;
		particle.density = 0;
	} else {
		float3 acceleration = CalculateAcceleration(particle, currentParticleIdx);
		//integrate
		particle.velocity += acceleration * timeStep;
		particle.position += particle.velocity * timeStep;
	}

	particleWrite[currentParticleIdx] = particle;
	particleRenderPositions[currentParticleIdx] = particle.position;
}

#pragma kernel ParticleDensity
[numthreads(64,1,1)]
void ParticleDensity(uint3 id : SV_DispatchThreadID)
{
	uint currentParticleIdx = id.x;
	if(currentParticleIdx >= nParticles){return;}

	Particle particle = particleRead[currentParticleIdx];

	float density = 0;

	for(uint i = 0; i < nParticles; i++)
	{
		if(i == currentParticleIdx) { continue; } //dont calculate self
		Particle neighbour = particleRead[i];
		float3 deltaPos = particle.position - neighbour.position;
		float weight = WPoly(deltaPos, interactionRadius); 
		density += weight;
	}

	particle.density = density;

	particleWrite[currentParticleIdx] = particle;
}